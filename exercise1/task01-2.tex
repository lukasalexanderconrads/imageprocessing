
\subsection*{task 1.2 \\[1ex] timing the emboss effect}

In the lecture, we also performed experiments to determine the minimum average runtime of our different methods for the \emph{emboss} effect. In this task you are supposed to conduct these experiments on your own machines.

Assuming that you have read an input intensity image into an array \texttt{arrF}, you may use the following code snippets for this purpose
\begin{python}
import timeit, functools


mtds = [embossV1, embossV2, embossV3, embossV4]

nRep =   3
nRun = 100
    
for mtd in mtds:
	ts = timeit.Timer(functools.partial(mtd, arrF)).repeat(nRep, nRun)
	print (min(ts) / nRun)
\end{python}



\begin{description}
\item[task 1.2(a):] In the \texttt{Data} folder, you will find the intensity image
\begin{quote}
    \texttt{portrait.png}
\end{quote}
Read it into an array \texttt{arrF}, print its shape, and run the above timing script.
\color{blue} \\[1ex]
%%%%%
%%%%%
%%%%% enter your result here
%%%%%
%%%%%
V1: 0.44967310061001625 \\
V2: 0.0007028839599661297 \\
V3: 0.0012256227100078832 \\
V4: 0.00038784879998274844 \\
%%%%%
%%%%%
%%%%%
%%%%%
%%%%%
\color{black}

\item[task 1.2(b):] In the \texttt{Data} folder, you will find the intensity image
\begin{quote}
    \texttt{asterix.png}
\end{quote}
Read it into an array \texttt{arrF}, print its shape, and run the above timing script.
\color{blue} \\[1ex]
%%%%%
%%%%%
%%%%% enter your result here
%%%%%
%%%%%
V1: 2.5130979724999998 \\
V2: 0.011546289530015201 \\
V3: 0.011558454990008613 \\
V4: 0.005792928150003718 \\
%%%%%
%%%%%
%%%%%
%%%%%
%%%%%
\color{black}

\newpage
\item[task 1.2(c):] Discuss your results. What do your experiments reveal? Is there any noteworthy difference between the runtimes for the two images? If so, what is the difference? What causes this difference? What does this tell you about image processing in general?
\color{blue} \\[1ex]
%%%%%
%%%%%
%%%%% enter your discussion here
%%%%%
%%%%%
The functions called on the second image take about 5.5 times longer, since the image has that much more pixels. The most noteworthy difference is between the first method and the others. The first takes far longer because it uses a python loop to iterate over all pixels, which are very slow compared to more low level programming languages. Meanwhile, numpy and scipy functions, like subtracting two arrays in methods 2 and 4, or the correlate function in 3, are implemented in C, where large loops are much faster.
%%%%%
%%%%%
%%%%%
%%%%%
%%%%%
\color{black}
\end{description}



